from xai_components.base import InArg, OutArg, InCompArg, Component, BaseComponent, xai_component, dynalist, SubGraphExecutor

import os
import tifffile
import numpy as np
from VolAlign import *
from VolAlign.pipeline_orchestrator import MicroscopyProcessingPipeline
from exm.stitching.tileset import Tileset


@xai_component(color="blue")
class CreateBDVXML(Component):
    """
    Component wrapper for VolAlign.create_bdv_xml.

    Creates a BDV/XML file for BigStitcher from a set of FOV TIFF images and their corresponding offsets.
    This component adjusts the provided column and row offsets based on unique values and writes the BDV/XML file
    using the npy2bdv library.

    ##### inPorts:
    - output_h5_file (str, compulsory): Path to the output .h5 file where the BDV/XML file and associated tile data will be saved.
    - fov_list (list, compulsory): List of file paths to the FOV TIFF images.
    - offset_list (list of lists, compulsory): List of lists containing offsets [column, row, z] for each FOV.
      This list is converted to a numpy array internally.
    - nchannels (int): Number of channels in each FOV image. Default is 1.
    - overlap_percentage (float): Overlap percentage between the tiles. Default is 0.05.

    ##### outPorts:
    - xml_path (str): The path to the created BDV XML file.
    """
    
    output_h5_file: InCompArg[str]
    fov_list: InCompArg[list]
    offset_list: InCompArg[list]

    nchannels: InArg[int]
    overlap_percentage: InArg[float]

    xml_path: OutArg[str]
    
    def execute(self, ctx) -> None:
        output_h5_file = self.output_h5_file.value
        fov_list = self.fov_list.value
        offset_array = np.array(self.offset_list.value)
        
        nchannels = self.nchannels.value if self.nchannels.value is not None else 1
        overlap = self.overlap_percentage.value if self.overlap_percentage.value is not None else 0.05
        increment_scale = (1 - overlap) * 2048

        try:
            xml_path = create_bdv_xml(
                    output_h5_file=output_h5_file,
                    fov_list=fov_list,
                    offset_array=offset_array,
                    nchannels=nchannels,
                    increment_scale=increment_scale
                )

            self.xml_path.value = xml_path
        except Exception as e:
            print(f"Error during BDV/XML creation: {e}")
            raise


@xai_component(color="magenta")
class StitchTiles(Component):
    """
    Component wrapper for VolAlign.stitch_tiles.

    Executes a tile stitching pipeline by generating an ImageJ macro and running Fiji in headless mode.
    This component constructs an ImageJ macro that:
      1. Calculates pairwise shifts using phase correlation.
      2. Filters pairwise shifts based on specified criteria.
      3. Optimizes the global alignment and applies the calculated shifts.
    The macro is written to a temporary file and executed by Fiji in headless mode.

    ##### inPorts:
    - xml_path (str, compulsory): Path to the BDV/XML file that contains the tile configuration.
    - fiji_path (str, compulsory): Full path to the Fiji executable.

    ##### outPorts:
    - None.
    """
    
    xml_path: InCompArg[str]
    fiji_path: InCompArg[str]
    
    def execute(self, ctx) -> None:
        xml_path = self.xml_path.value
        fiji_path = self.fiji_path.value
        
        try:
            stitch_tiles(xml_path, fiji_path)
            print(f"Tile stitching executed successfully using XML: {xml_path} and Fiji: {fiji_path}")
        except Exception as e:
            print(f"Error during tile stitching: {e}")
            raise


@xai_component(color="green")
class BlendTiles(Component):
    """
    Component wrapper for VolAlign.blend_tiles.

    Blends stitched tile images for each channel and saves a TIFF file for each channel.
    This component performs the following steps:
      1. Loads a tileset from a BDV/XML file (updated by BigStitcher) using the provided voxel size.
      2. Groups tiles into chunks of size 'num_of_tiles / num_of_channels', assuming each group corresponds to one channel.
      3. For each group, computes offsets (converted to pixel units by dividing by the voxel size)
         and collects the corresponding image tiles.
      4. Blends the collected tiles using `blend_ind` to generate a single volume per channel.
      5. Saves the blended volume as a TIFF file named "stitched_{channel}.tif" in the specified output folder.

    ##### inPorts:
    - xml_file (str, compulsory): Path to the BDV/XML file generated by BigStitcher.
    - output_folder (str, compulsory): Folder where the output TIFF files will be saved.
    - voxel_size (list, compulsory): Voxel size as a list in [z, y, x] order.
    - channels_names (list, compulsory): List of channel names (e.g., ['CH1', 'CH2']).

    ##### outPorts:
    - output_files (list): List of paths to the blended TIFF files for each channel.
    """
    
    xml_file: InCompArg[str]
    output_folder: InCompArg[str]
    voxel_size: InCompArg[list]
    channels_names: InCompArg[list]

    output_files: OutArg[list]
    
    def execute(self, ctx) -> None:
        xml_file = self.xml_file.value
        output_folder = self.output_folder.value
        voxel_size = self.voxel_size.value
        channels_names = self.channels_names.value
        
        try:
            output_path = blend_tiles(
                xml_file=xml_file,
                output_folder=output_folder,
                voxel_size=voxel_size,
                channels=channels_names
            )
            self.output_files.value = output_path
        except Exception as e:
            print(f"Error during tile blending: {e}")
            raise


@xai_component(color="green")
class VoxelSpacingResample(Component):
    """
    Component wrapper for VolAlign.voxel_spacing_resample.

    Loads a 3D .tif image, sets its original spacing, and resamples it to a target spacing.
    The component performs the following steps:
      1. Reads the image from the provided .tif file path.
      2. Converts the image to a SimpleITK image and casts it to uint16.
      3. Sets the image's original spacing.
      4. Computes the new image size based on the target spacing.
      5. Uses a SimpleITK resampler with the specified interpolator (default: sitk.sitkLinear)
         to adjust the image to the desired target spacing.
      6. Writes the resampled image to the specified output path.

    **Note:** The provided spacing values are given in [z, y, x] order and are internally re-ordered to [x, y, z] before resampling.

    ##### inPorts:
    - input_file (str, compulsory): Path to the 3D .tif image file.
    - output_path (str, compulsory): Path where the resampled 3D .tif image will be saved.
    - original_spacing (list, compulsory): Original spacing in [z, y, x] order.
    - target_spacing (list, compulsory): Desired target spacing in [z, y, x] order.

    ##### outPorts:
    - None.
    """
    
    input_file: InCompArg[str]
    output_path: InCompArg[str]
    original_spacing: InCompArg[list]
    target_spacing: InCompArg[list]
    
    def execute(self, ctx) -> None:
        input_file = self.input_file.value
        output_path = self.output_path.value
        original_spacing = self.original_spacing.value
        target_spacing = self.target_spacing.value
        
        try:
            resampled = voxel_spacing_resample(
                input_file=input_file,
                output_path=output_path,
                original_spacing=[original_spacing[2], original_spacing[1], original_spacing[0]],
                target_spacing=[target_spacing[2], target_spacing[1], target_spacing[0]]
            )

            print(f"Resampling completed. Resampled image saved to {output_path}")
        except Exception as e:
            print(f"Error during voxel spacing resampling: {e}")
            raise



@xai_component(color="purple")
class ApplyManualAlignment(Component):
    """
    Component wrapper for VolAlign.apply_manual_alignment.

    Aligns a moving volume to a fixed volume using an affine transformation read from a file.
    This component performs the following steps:
      1. Loads a 3x4 transformation matrix from a text file and constructs a 4x4 homogeneous transformation matrix.
      2. Reads the fixed and moving image volumes from TIFF files and converts them into SimpleITK images.
      3. Sets up an affine transform using the transformation matrix.
      4. Resamples the moving image to align it with the fixed image.
      5. Writes the resampled moving image and the fixed image to the specified output paths.

    ##### inPorts:
    - matrix_file_path (str, compulsory): Path to the text file containing a 3x4 transformation matrix.
    - fixed_volume_path (str, compulsory): Path to the fixed (reference) image volume in TIFF format.
    - moving_volume_path (str, compulsory): Path to the moving image volume in TIFF format.
    - resample_output_fixed_path (str, compulsory): Output path for writing the fixed image in TIFF format.
    - resample_output_moving_path (str, compulsory): Output path for writing the resampled moving image in TIFF format.

    ##### outPorts:
    - None.
    """
    
    matrix_file_path: InCompArg[str]
    fixed_volume_path: InCompArg[str]
    moving_volume_path: InCompArg[str]
    resample_output_fixed_path: InCompArg[str]
    resample_output_moving_path: InCompArg[str]
    
    def execute(self, ctx) -> None:
        matrix_file_path = self.matrix_file_path.value
        fixed_volume_path = self.fixed_volume_path.value
        moving_volume_path = self.moving_volume_path.value
        resample_output_fixed_path = self.resample_output_fixed_path.value
        resample_output_moving_path = self.resample_output_moving_path.value
        
        try:
            apply_manual_alignment(
                matrix_file_path=matrix_file_path,
                fixed_volume_path=fixed_volume_path,
                moving_volume_path=moving_volume_path,
                resample_output_fixed_path=resample_output_fixed_path,
                resample_output_moving_path=resample_output_moving_path
            )
            print("Alignment applied successfully.")
        except Exception as e:
            print(f"Error during alignment: {e}")
            raise


@xai_component(color="orange")
class LinearAlignmentTuning(Component):
    """
    Component wrapper for VolAlign.linear_alignment_tuning.

    Executes an alignment pipeline between fixed and moving 3D volumes and saves the resulting
    affine transformation matrix.

    The component performs the following steps:
      1. Reads two 3D TIFF volumes (fixed and moving) from the provided file paths.
      2. Prints the shapes of the input volumes for verification.
      3. Uses a customizable set of alignment steps. If no steps are provided, a default configuration is used.
      4. Calls the alignment pipeline to compute the affine transformation matrix.
      5. Saves the computed affine transformation matrix to a text file.

    **Note:** The provided `fixed_spacing` and `moving_spacing` values (in [z, y, x] order) are scaled by the 
    downsampling `factors` before alignment.

    ##### inPorts:
    - fixed_path (str, compulsory): File path to the fixed TIFF volume.
    - moving_path (str, compulsory): File path to the moving TIFF volume.
    - fixed_spacing (list, compulsory): Original spacing for the fixed volume in [z, y, x] order.
    - moving_spacing (list, compulsory): Original spacing for the moving volume in [z, y, x] order.
    - steps (list): List of alignment steps. Each step is a tuple with the transformation type (e.g., 'affine') 
                    and a dictionary of parameters. If None, a default set of steps is used.
    - factors (tuple): Optional downsampling factors for each axis. Defaults to (1, 1, 1) if not provided.
    - output_matrix_file (str, compulsory): File path where the computed affine transformation matrix will be saved.

    ##### outPorts:
    - affine_matrix (np.ndarray): The computed affine transformation matrix.
    """
    
    fixed_path: InCompArg[str]
    moving_path: InCompArg[str]
    fixed_spacing: InCompArg[list]
    moving_spacing: InCompArg[list]    
    steps: InArg[list]
    factors: InArg[tuple]
    output_matrix_file: InCompArg[str]
    
    affine_matrix: OutArg[object]
    
    def execute(self, ctx) -> None:
        fixed_path = self.fixed_path.value
        moving_path = self.moving_path.value
        fixed_spacing = self.fixed_spacing.value
        moving_spacing = self.moving_spacing.value
        output_matrix_file = self.output_matrix_file.value
        factors = self.factors.value if self.factors.value is not None else (1, 1, 1)
        steps = self.steps.value if self.steps.value is not None else None
        
        try:
            result = linear_alignment_tuning(
                fixed_path=fixed_path,
                moving_path=moving_path,
                fixed_spacing=np.array(fixed_spacing) * factors,
                moving_spacing=np.array(moving_spacing) * factors,
                output_matrix_file=output_matrix_file,
                steps=steps
            )
            self.affine_matrix.value = result
        except Exception as e:
            print(f"Error during linear alignment tuning: {e}")
            raise


@xai_component(color="cyan")
class ConvertZarrToTiff(Component):
    """
    Component wrapper for VolAlign.convert_zarr_to_tiff.

    Convert Zarr volumes to TIFF format with optional chunked processing for large volumes.
    For small volumes (chunk_size=None), loads entire volume into memory for fast conversion.
    For large volumes, processes in chunks to avoid memory issues.

    ##### inPorts:
    - zarr_file (str, compulsory): Path to the input Zarr file.
    - tiff_file (str, compulsory): Path to the output TIFF file.
    - chunk_size (int): Number of Z-slices to process at once. If None, loads entire volume (faster for small volumes).
    - photometric (str): TIFF photometric interpretation. Default is 'minisblack'.

    ##### outPorts:
    - None.
    """
    zarr_file: InCompArg[str]
    tiff_file: InCompArg[str]
    chunk_size: InArg[int]
    photometric: InArg[str]

    def execute(self, ctx) -> None:
        zarr_file = self.zarr_file.value
        tiff_file = self.tiff_file.value
        chunk_size = self.chunk_size.value if self.chunk_size.value is not None else None
        photometric = self.photometric.value if self.photometric.value is not None else 'minisblack'
        
        try:
            convert_zarr_to_tiff(
                zarr_path=zarr_file,
                tiff_path=tiff_file,
                chunk_size=chunk_size,
                photometric=photometric
            )
            print(f"Converted Zarr file {zarr_file} to TIFF file {tiff_file}")
        except Exception as e:
            print(f"Error in convert_zarr_to_tiff: {e}")
            raise


@xai_component(color="teal")
class ConvertTiffToZarr(Component):
    """
    Component wrapper for VolAlign.convert_tiff_to_zarr.

    Converts a TIFF image file to a Zarr-formatted file.
    This component reads a TIFF image file into a NumPy array and saves it in Zarr format,
    supporting multi-dimensional image data.

    ##### inPorts:
    - tiff_file (str, compulsory): Path to the input TIFF file.
    - zarr_file (str, compulsory): Path where the output Zarr file will be stored.

    ##### outPorts:
    - None.
    """
    tiff_file: InCompArg[str]
    zarr_file: InCompArg[str]

    def execute(self, ctx) -> None:
        tiff_file = self.tiff_file.value
        zarr_file = self.zarr_file.value
        try:
            convert_tiff_to_zarr(tiff_file, zarr_file)
        except Exception as e:
            print(f"Error in convert_tiff_to_zarr: {e}")
            raise


@xai_component(color="brown")
class DownsampleTiff(Component):
    """
    Component wrapper for VolAlign.downsample_tiff.

    Reads a 3D TIFF image, downsamples it using specified factors and interpolation order,
    and writes the downsampled image to a new TIFF file.
    The downsampling scale is computed as the reciprocal of each provided factor.

    ##### inPorts:
    - input_path (str, compulsory): Path to the input TIFF file containing the original 3D image volume.
    - output_path (str, compulsory): Path where the downsampled TIFF image will be saved.
    - factors (tuple, compulsory): Downsampling factors for each axis (e.g., (6, 6, 6)).
    - order (int): The order of the spline interpolation used in zoom. Default is 1 (linear interpolation).

    ##### outPorts:
    - None.
    """
    input_path: InCompArg[str]
    output_path: InCompArg[str]
    factors: InCompArg[tuple]
    order: InArg[int]

    def execute(self, ctx) -> None:
        input_path = self.input_path.value
        output_path = self.output_path.value
        factors = self.factors.value
        order = self.order.value if self.order.value is not None else 1
        try:
            downsample_tiff(input_path, output_path, factors, order)
        except Exception as e:
            print(f"Error in downsample_tiff: {e}")
            raise


@xai_component(color="yellow")
class StackTiffImages(Component):
    """
    Component wrapper for VolAlign.stack_tiff_images.

    Reads two TIFF files, verifies they have the same shape, stacks them along a new channel axis,
    and saves the resulting stacked image to an output file.

    ##### inPorts:
    - file1 (str, compulsory): Path to the first input TIFF file.
    - file2 (str, compulsory): Path to the second input TIFF file.
    - output_file (str, compulsory): Path where the output stacked TIFF image will be saved.

    ##### outPorts:
    - None.
    """
    file1: InCompArg[str]
    file2: InCompArg[str]
    output_file: InCompArg[str]

    def execute(self, ctx) -> None:
        file1 = self.file1.value
        file2 = self.file2.value
        output_file = self.output_file.value
        try:
            stack_tiff_images(file1, file2, output_file)
        except Exception as e:
            print(f"Error in stack_tiff_images: {e}")
            raise


@xai_component(color="purple")
class ReorientVolume(Component):
    """
    Component wrapper for VolAlign.reorient_volume_and_save_tiff.

    Reads a 3D volume from a TIFF file, reorients it by applying a specified rotation (in multiples of 90°)
    and an optional flip along the first (z) axis, and saves the resulting volume as a TIFF file.

    ##### inPorts:
    - input_path (str, compulsory): Path to the input TIFF file containing the 3D volume.
    - output_path (str, compulsory): Path where the reoriented TIFF file will be saved.
    - rotation (int, compulsory): Rotation angle in degrees. Must be one of [0, 90, 180, 270].
    - flip (bool, compulsory): If True, flip the volume along the first (z) axis after rotation.

    ##### outPorts:
    - reoriented_volume (np.ndarray): The reoriented volume.
    """
    input_path: InCompArg[str]
    output_path: InCompArg[str]
    rotation: InCompArg[int]
    flip: InCompArg[bool]

    reoriented_volume: OutArg[object]

    def execute(self, ctx) -> None:
        input_path = self.input_path.value
        output_path = self.output_path.value
        rotation = self.rotation.value
        flip = self.flip.value
        try:
            result = reorient_volume_and_save_tiff(input_path, output_path, rotation, flip)
            self.reoriented_volume.value = result
        except Exception as e:
            print(f"Error in reorient_volume_and_save_tiff: {e}")
            raise


# =============================================================================
# NEW ENHANCED VOLALIGN COMPONENTS
# =============================================================================


@xai_component(color="lightblue")
class DownsampleZarrVolume(Component):
    """
    Component wrapper for VolAlign.downsample_zarr_volume.

    Memory-efficient downsampling of Zarr volumes with chunked processing.
    Processes the volume in chunks to avoid loading the entire dataset into memory,
    making it suitable for very large microscopy volumes.

    ##### inPorts:
    - input_zarr_path (str, compulsory): Path to input Zarr volume.
    - output_zarr_path (str, compulsory): Path for output downsampled Zarr volume.
    - downsample_factors (tuple, compulsory): Downsampling factors for (z, y, x).
    - chunk_size (int): Number of Z-slices to process at once. Default is 50.
    - compression (str): Compression algorithm ('zstd', 'lz4', 'blosc'). Default is 'zstd'.
    - compression_level (int): Compression level (1-9). Default is 3.

    ##### outPorts:
    - None.
    """
    
    input_zarr_path: InCompArg[str]
    output_zarr_path: InCompArg[str]
    downsample_factors: InCompArg[tuple]
    chunk_size: InArg[int]
    compression: InArg[str]
    compression_level: InArg[int]
    
    def execute(self, ctx) -> None:
        input_zarr_path = self.input_zarr_path.value
        output_zarr_path = self.output_zarr_path.value
        downsample_factors = self.downsample_factors.value
        chunk_size = self.chunk_size.value if self.chunk_size.value is not None else 50
        compression = self.compression.value if self.compression.value is not None else 'zstd'
        compression_level = self.compression_level.value if self.compression_level.value is not None else 3
        
        try:
            downsample_zarr_volume(
                input_zarr_path=input_zarr_path,
                output_zarr_path=output_zarr_path,
                downsample_factors=downsample_factors,
                chunk_size=chunk_size,
                compression=compression,
                compression_level=compression_level
            )
            print(f"Zarr volume downsampling completed: {output_zarr_path}")
        except Exception as e:
            print(f"Error during Zarr volume downsampling: {e}")
            raise


@xai_component(color="lightgreen")
class UpsampleSegmentationLabels(Component):
    """
    Component wrapper for VolAlign.upsample_segmentation_labels.

    Upsample segmentation label volumes while preserving integer label values.
    Uses nearest-neighbor interpolation (order=0) to maintain discrete integer
    labels during upsampling, essential for segmentation masks.

    ##### inPorts:
    - input_zarr_path (str, compulsory): Path to input segmentation Zarr volume.
    - output_zarr_path (str, compulsory): Path for upsampled output Zarr volume.
    - upsample_factors (tuple, compulsory): Upsampling factors for (z, y, x).
    - chunk_size (int): Number of Z-slices to process at once. Default is 50.
    - compression (str): Compression algorithm for output. Default is 'zstd'.
    - target_shape (tuple): Override output shape (z, y, x). If provided, takes precedence over calculated shape.

    ##### outPorts:
    - None.
    """
    
    input_zarr_path: InCompArg[str]
    output_zarr_path: InCompArg[str]
    upsample_factors: InCompArg[tuple]
    chunk_size: InArg[int]
    compression: InArg[str]
    target_shape: InArg[tuple]
    
    def execute(self, ctx) -> None:
        input_zarr_path = self.input_zarr_path.value
        output_zarr_path = self.output_zarr_path.value
        upsample_factors = self.upsample_factors.value
        chunk_size = self.chunk_size.value if self.chunk_size.value is not None else 50
        compression = self.compression.value if self.compression.value is not None else 'zstd'
        target_shape = self.target_shape.value if self.target_shape.value is not None else None
        
        try:
            upsample_segmentation_labels(
                input_zarr_path=input_zarr_path,
                output_zarr_path=output_zarr_path,
                upsample_factors=upsample_factors,
                chunk_size=chunk_size,
                compression=compression,
                target_shape=target_shape
            )
            print(f"Segmentation label upsampling completed: {output_zarr_path}")
        except Exception as e:
            print(f"Error during segmentation label upsampling: {e}")
            raise


@xai_component(color="coral")
class MergeZarrChannels(Component):
    """
    Component wrapper for VolAlign.merge_zarr_channels.

    Memory-efficient merging of two Zarr volumes representing different imaging channels.
    Supports different merging strategies for combining channels (e.g., 405nm and 488nm)
    commonly used in microscopy registration workflows.

    ##### inPorts:
    - channel_a_path (str, compulsory): Path to first channel Zarr volume.
    - channel_b_path (str, compulsory): Path to second channel Zarr volume.
    - output_path (str, compulsory): Path for merged output Zarr volume.
    - merge_strategy (str): Merging method - "mean", "max", or "stack". Default is "mean".
    - block_depth (int): Number of Z-slices to process per block. Default is 50.
    - compression (str): Compression algorithm for output. Default is 'zstd'.

    ##### outPorts:
    - None.
    """
    
    channel_a_path: InCompArg[str]
    channel_b_path: InCompArg[str]
    output_path: InCompArg[str]
    merge_strategy: InArg[str]
    block_depth: InArg[int]
    compression: InArg[str]
    
    def execute(self, ctx) -> None:
        channel_a_path = self.channel_a_path.value
        channel_b_path = self.channel_b_path.value
        output_path = self.output_path.value
        merge_strategy = self.merge_strategy.value if self.merge_strategy.value is not None else "mean"
        block_depth = self.block_depth.value if self.block_depth.value is not None else 50
        compression = self.compression.value if self.compression.value is not None else 'zstd'
        
        try:
            merge_zarr_channels(
                channel_a_path=channel_a_path,
                channel_b_path=channel_b_path,
                output_path=output_path,
                merge_strategy=merge_strategy,
                block_depth=block_depth,
                compression=compression
            )
            print(f"Zarr channel merging completed: {output_path}")
        except Exception as e:
            print(f"Error during Zarr channel merging: {e}")
            raise


@xai_component(color="gold")
class ScaleIntensityToUint16(Component):
    """
    Component wrapper for VolAlign.scale_intensity_to_uint16.

    Scale intensity values in a Zarr volume to uint16 range [0, 65535].
    Useful for normalizing microscopy data before processing or visualization.

    ##### inPorts:
    - input_zarr_path (str, compulsory): Path to input Zarr volume.
    - output_zarr_path (str, compulsory): Path for scaled output Zarr volume.
    - intensity_range (tuple): Min/max values for scaling. If None, uses global min/max.
    - chunk_size (int): Number of Z-slices to process at once. Default is 50.

    ##### outPorts:
    - None.
    """
    
    input_zarr_path: InCompArg[str]
    output_zarr_path: InCompArg[str]
    intensity_range: InArg[tuple]
    chunk_size: InArg[int]
    
    def execute(self, ctx) -> None:
        input_zarr_path = self.input_zarr_path.value
        output_zarr_path = self.output_zarr_path.value
        intensity_range = self.intensity_range.value if self.intensity_range.value is not None else None
        chunk_size = self.chunk_size.value if self.chunk_size.value is not None else 50
        
        try:
            scale_intensity_to_uint16(
                input_zarr_path=input_zarr_path,
                output_zarr_path=output_zarr_path,
                intensity_range=intensity_range,
                chunk_size=chunk_size
            )
            print(f"Intensity scaling completed: {output_zarr_path}")
        except Exception as e:
            print(f"Error during intensity scaling: {e}")
            raise


@xai_component(color="darkblue")
class ComputeAffineRegistration(Component):
    """
    Component wrapper for VolAlign.compute_affine_registration.

    Compute initial affine registration between two microscopy volumes.
    Performs coarse alignment on downsampled volumes using feature-based registration
    followed by gradient descent optimization. This replaces the "initial" alignment step.

    ##### inPorts:
    - fixed_volume_path (str, compulsory): Path to reference volume (TIFF or Zarr).
    - moving_volume_path (str, compulsory): Path to volume to be aligned (TIFF or Zarr).
    - voxel_spacing (list, compulsory): Voxel spacing in [z, y, x] order (microns).
    - output_matrix_path (str, compulsory): Path to save the computed affine transformation matrix.
    - downsample_factors (tuple): Downsampling factors for (z, y, x). Default is (4, 7, 7).
    - alignment_steps (list): Custom alignment pipeline steps. If None, uses default.

    ##### outPorts:
    - affine_matrix (np.ndarray): The computed 4x4 affine transformation matrix.
    """
    
    fixed_volume_path: InCompArg[str]
    moving_volume_path: InCompArg[str]
    voxel_spacing: InCompArg[list]
    output_matrix_path: InCompArg[str]
    downsample_factors: InArg[tuple]
    alignment_steps: InArg[list]
    
    affine_matrix: OutArg[object]
    
    def execute(self, ctx) -> None:
        fixed_volume_path = self.fixed_volume_path.value
        moving_volume_path = self.moving_volume_path.value
        voxel_spacing = self.voxel_spacing.value
        output_matrix_path = self.output_matrix_path.value
        downsample_factors = self.downsample_factors.value if self.downsample_factors.value is not None else (4, 7, 7)
        alignment_steps = self.alignment_steps.value if self.alignment_steps.value is not None else None
        
        try:
            affine_matrix = compute_affine_registration(
                fixed_volume_path=fixed_volume_path,
                moving_volume_path=moving_volume_path,
                voxel_spacing=voxel_spacing,
                output_matrix_path=output_matrix_path,
                downsample_factors=downsample_factors,
                alignment_steps=alignment_steps
            )
            self.affine_matrix.value = affine_matrix
            print(f"Affine registration completed: {output_matrix_path}")
        except Exception as e:
            print(f"Error during affine registration: {e}")
            raise


@xai_component(color="darkgreen")
class ComputeDeformationFieldRegistration(Component):
    """
    Component wrapper for VolAlign.compute_deformation_field_registration.

    Compute dense deformation field registration for precise alignment.
    Applies initial affine transformation then computes a dense deformation field
    for fine-grained alignment. This replaces the "final" alignment step.

    ##### inPorts:
    - fixed_zarr_path (str, compulsory): Path to reference Zarr volume.
    - moving_zarr_path (str, compulsory): Path to moving Zarr volume.
    - affine_matrix_path (str, compulsory): Path to initial affine transformation matrix.
    - output_directory (str, compulsory): Directory to save alignment results.
    - output_name (str, compulsory): Base name for output files.
    - voxel_spacing (list, compulsory): Voxel spacing in [z, y, x] order (microns).
    - block_size (list): Block size for distributed processing. Default is [512, 512, 512].
    - cluster_config (dict): Dask cluster configuration. If None, uses default.

    ##### outPorts:
    - final_aligned_path (str): Path to the final aligned volume.
    """
    
    fixed_zarr_path: InCompArg[str]
    moving_zarr_path: InCompArg[str]
    affine_matrix_path: InCompArg[str]
    output_directory: InCompArg[str]
    output_name: InCompArg[str]
    voxel_spacing: InCompArg[list]
    block_size: InArg[list]
    cluster_config: InArg[dict]
    
    final_aligned_path: OutArg[str]
    
    def execute(self, ctx) -> None:
        fixed_zarr_path = self.fixed_zarr_path.value
        moving_zarr_path = self.moving_zarr_path.value
        affine_matrix_path = self.affine_matrix_path.value
        output_directory = self.output_directory.value
        output_name = self.output_name.value
        voxel_spacing = self.voxel_spacing.value
        block_size = self.block_size.value if self.block_size.value is not None else [512, 512, 512]
        cluster_config = self.cluster_config.value if self.cluster_config.value is not None else None
        
        try:
            final_aligned_path = compute_deformation_field_registration(
                fixed_zarr_path=fixed_zarr_path,
                moving_zarr_path=moving_zarr_path,
                affine_matrix_path=affine_matrix_path,
                output_directory=output_directory,
                output_name=output_name,
                voxel_spacing=voxel_spacing,
                block_size=block_size,
                cluster_config=cluster_config
            )
            self.final_aligned_path.value = final_aligned_path
            print(f"Deformation field registration completed: {final_aligned_path}")
        except Exception as e:
            print(f"Error during deformation field registration: {e}")
            raise


@xai_component(color="red")
class DistributedNucleiSegmentation(Component):
    """
    Component wrapper for VolAlign.distributed_nuclei_segmentation.

    Perform distributed nuclei segmentation on large microscopy volumes.
    Uses Cellpose with distributed processing to segment nuclei in 3D volumes,
    typically applied to the 405nm channel for nuclear segmentation.

    ##### inPorts:
    - input_zarr_path (str, compulsory): Path to input Zarr volume (typically 405nm channel).
    - output_zarr_path (str, compulsory): Path for output segmentation masks.
    - model_type (str): Cellpose model type ('cpsam', 'nuclei', etc.). Default is 'cpsam'.
    - block_size (tuple): Processing block size (z, y, x). Default is (500, 1024, 1024).
    - preprocessing_sigma (float): Gaussian smoothing sigma for preprocessing. Default is 2.0.
    - cluster_config (dict): Dask cluster configuration. If None, uses default.
    - temporary_directory (str): Directory for temporary files. If None, uses output directory.

    ##### outPorts:
    - segments (object): Segmentation results.
    - bounding_boxes (list): List of bounding boxes for detected objects.
    - num_objects (int): Number of detected objects.
    """
    
    input_zarr_path: InCompArg[str]
    output_zarr_path: InCompArg[str]
    model_type: InArg[str]
    block_size: InArg[tuple]
    preprocessing_sigma: InArg[float]
    cluster_config: InArg[dict]
    temporary_directory: InArg[str]
    
    segments: OutArg[object]
    bounding_boxes: OutArg[list]
    num_objects: OutArg[int]
    
    def execute(self, ctx) -> None:
        input_zarr_path = self.input_zarr_path.value
        output_zarr_path = self.output_zarr_path.value
        model_type = self.model_type.value if self.model_type.value is not None else 'cpsam'
        block_size = self.block_size.value if self.block_size.value is not None else (500, 1024, 1024)
        preprocessing_sigma = self.preprocessing_sigma.value if self.preprocessing_sigma.value is not None else 2.0
        cluster_config = self.cluster_config.value if self.cluster_config.value is not None else None
        temporary_directory = self.temporary_directory.value if self.temporary_directory.value is not None else None
        
        try:
            segments, bounding_boxes = distributed_nuclei_segmentation(
                input_zarr_path=input_zarr_path,
                output_zarr_path=output_zarr_path,
                model_type=model_type,
                block_size=block_size,
                preprocessing_sigma=preprocessing_sigma,
                cluster_config=cluster_config,
                temporary_directory=temporary_directory
            )
            self.segments.value = segments
            self.bounding_boxes.value = bounding_boxes
            self.num_objects.value = len(bounding_boxes)
            print(f"Distributed nuclei segmentation completed: {output_zarr_path}")
            print(f"Number of detected objects: {len(bounding_boxes)}")
        except Exception as e:
            print(f"Error during distributed nuclei segmentation: {e}")
            raise


@xai_component(color="darkmagenta")
class ApplyDeformationToChannels(Component):
    """
    Component wrapper for VolAlign.apply_deformation_to_channels.

    Apply computed deformation field to multiple imaging channels.
    Uses the deformation field computed from registration channels (405nm, 488nm)
    to align all other imaging channels (epitope markers) for consistent multi-round analysis.

    ##### inPorts:
    - reference_zarr_path (str, compulsory): Path to reference volume (fixed).
    - channel_zarr_paths (list, compulsory): Paths to channel volumes to be transformed.
    - deformation_field_path (str, compulsory): Path to computed deformation field.
    - output_directory (str, compulsory): Directory for aligned channel outputs.
    - voxel_spacing (list, compulsory): Voxel spacing in [z, y, x] order.
    - block_size (list): Block size for distributed processing. Default is [512, 512, 512].
    - cluster_config (dict): Dask cluster configuration. If None, uses default.

    ##### outPorts:
    - aligned_channel_paths (list): Paths to aligned channel volumes.
    """
    
    reference_zarr_path: InCompArg[str]
    channel_zarr_paths: InCompArg[list]
    deformation_field_path: InCompArg[str]
    output_directory: InCompArg[str]
    voxel_spacing: InCompArg[list]
    block_size: InArg[list]
    cluster_config: InArg[dict]
    
    aligned_channel_paths: OutArg[list]
    
    def execute(self, ctx) -> None:
        reference_zarr_path = self.reference_zarr_path.value
        channel_zarr_paths = self.channel_zarr_paths.value
        deformation_field_path = self.deformation_field_path.value
        output_directory = self.output_directory.value
        voxel_spacing = self.voxel_spacing.value
        block_size = self.block_size.value if self.block_size.value is not None else [512, 512, 512]
        cluster_config = self.cluster_config.value if self.cluster_config.value is not None else None
        
        try:
            aligned_paths = apply_deformation_to_channels(
                reference_zarr_path=reference_zarr_path,
                channel_zarr_paths=channel_zarr_paths,
                deformation_field_path=deformation_field_path,
                output_directory=output_directory,
                voxel_spacing=voxel_spacing,
                block_size=block_size,
                cluster_config=cluster_config
            )
            self.aligned_channel_paths.value = aligned_paths
            print(f"Deformation applied to {len(aligned_paths)} channels")
        except Exception as e:
            print(f"Error during deformation application to channels: {e}")
            raise


@xai_component(color="darkcyan")
class CreateRegistrationSummary(Component):
    """
    Component wrapper for VolAlign.create_registration_summary.

    Create a comprehensive summary of the registration process.
    Generates metadata and quality metrics for the registration workflow,
    useful for tracking and validating alignment results.

    ##### inPorts:
    - fixed_path (str, compulsory): Path to reference volume.
    - moving_path (str, compulsory): Path to moving volume.
    - affine_matrix_path (str, compulsory): Path to affine transformation matrix.
    - deformation_field_path (str, compulsory): Path to deformation field.
    - final_aligned_path (str, compulsory): Path to final aligned volume.
    - output_summary_path (str, compulsory): Path to save summary JSON.

    ##### outPorts:
    - summary (dict): Registration summary dictionary.
    """
    
    fixed_path: InCompArg[str]
    moving_path: InCompArg[str]
    affine_matrix_path: InCompArg[str]
    deformation_field_path: InCompArg[str]
    final_aligned_path: InCompArg[str]
    output_summary_path: InCompArg[str]
    
    summary: OutArg[dict]
    
    def execute(self, ctx) -> None:
        fixed_path = self.fixed_path.value
        moving_path = self.moving_path.value
        affine_matrix_path = self.affine_matrix_path.value
        deformation_field_path = self.deformation_field_path.value
        final_aligned_path = self.final_aligned_path.value
        output_summary_path = self.output_summary_path.value
        
        try:
            summary = create_registration_summary(
                fixed_path=fixed_path,
                moving_path=moving_path,
                affine_matrix_path=affine_matrix_path,
                deformation_field_path=deformation_field_path,
                final_aligned_path=final_aligned_path,
                output_summary_path=output_summary_path
            )
            self.summary.value = summary
            print(f"Registration summary created: {output_summary_path}")
        except Exception as e:
            print(f"Error during registration summary creation: {e}")
            raise


@xai_component(color="indigo")
class MicroscopyProcessingPipelineComponent(Component):
    """
    Component wrapper for VolAlign.MicroscopyProcessingPipeline.

    High-level orchestrator for multi-round microscopy processing workflows.
    Manages the complete pipeline from raw data to aligned, segmented volumes
    including registration, segmentation, and channel processing.

    ##### inPorts:
    - config (dict, compulsory): Pipeline configuration dictionary containing:
        - working_directory: Base directory for processing
        - voxel_spacing: Voxel spacing in [z, y, x] order (microns)
        - downsample_factors: Downsampling factors for (z, y, x)
        - block_size: Block size for distributed processing
        - cluster_config: Dask cluster configuration
    - operation (str, compulsory): Operation to perform:
        - "prepare_round_data": Convert TIFF files to Zarr format
        - "run_registration_workflow": Execute complete registration workflow
        - "run_segmentation_workflow": Execute nuclei segmentation workflow
        - "apply_registration_to_all_channels": Apply registration to all channels
        - "save_pipeline_state": Save current pipeline state
        - "generate_processing_report": Generate comprehensive report
    - operation_params (dict, compulsory): Parameters specific to the chosen operation

    ##### outPorts:
    - pipeline (object): The MicroscopyProcessingPipeline instance.
    - result (object): Result of the executed operation.
    """
    
    config: InCompArg[dict]
    operation: InCompArg[str]
    operation_params: InCompArg[dict]
    
    pipeline: OutArg[object]
    result: OutArg[object]
    
    def execute(self, ctx) -> None:
        config = self.config.value
        operation = self.operation.value
        operation_params = self.operation_params.value
        
        try:
            # Initialize or reuse pipeline
            if not hasattr(self, '_pipeline') or self._pipeline is None:
                self._pipeline = MicroscopyProcessingPipeline(config)
            
            pipeline = self._pipeline
            result = None
            
            if operation == "prepare_round_data":
                # Required params: round_name, tiff_files, output_zarr_dir (optional)
                round_name = operation_params["round_name"]
                tiff_files = operation_params["tiff_files"]
                output_zarr_dir = operation_params.get("output_zarr_dir", None)
                
                result = pipeline.prepare_round_data(
                    round_name=round_name,
                    tiff_files=tiff_files,
                    output_zarr_dir=output_zarr_dir
                )
                
            elif operation == "run_registration_workflow":
                # Required params: fixed_round_data, moving_round_data, registration_output_dir, registration_name
                fixed_round_data = operation_params["fixed_round_data"]
                moving_round_data = operation_params["moving_round_data"]
                registration_output_dir = operation_params["registration_output_dir"]
                registration_name = operation_params["registration_name"]
                
                result = pipeline.run_registration_workflow(
                    fixed_round_data=fixed_round_data,
                    moving_round_data=moving_round_data,
                    registration_output_dir=registration_output_dir,
                    registration_name=registration_name
                )
                
            elif operation == "run_segmentation_workflow":
                # Required params: input_405_channel, segmentation_output_dir, segmentation_name
                # Optional params: downsample_for_segmentation, upsample_results
                input_405_channel = operation_params["input_405_channel"]
                segmentation_output_dir = operation_params["segmentation_output_dir"]
                segmentation_name = operation_params["segmentation_name"]
                downsample_for_segmentation = operation_params.get("downsample_for_segmentation", True)
                upsample_results = operation_params.get("upsample_results", True)
                
                result = pipeline.run_segmentation_workflow(
                    input_405_channel=input_405_channel,
                    segmentation_output_dir=segmentation_output_dir,
                    segmentation_name=segmentation_name,
                    downsample_for_segmentation=downsample_for_segmentation,
                    upsample_results=upsample_results
                )
                
            elif operation == "apply_registration_to_all_channels":
                # Required params: reference_round_data, target_round_data, deformation_field_path, output_directory
                reference_round_data = operation_params["reference_round_data"]
                target_round_data = operation_params["target_round_data"]
                deformation_field_path = operation_params["deformation_field_path"]
                output_directory = operation_params["output_directory"]
                
                result = pipeline.apply_registration_to_all_channels(
                    reference_round_data=reference_round_data,
                    target_round_data=target_round_data,
                    deformation_field_path=deformation_field_path,
                    output_directory=output_directory
                )
                
            elif operation == "save_pipeline_state":
                # Required params: output_path
                output_path = operation_params["output_path"]
                pipeline.save_pipeline_state(output_path)
                result = f"Pipeline state saved to: {output_path}"
                
            elif operation == "generate_processing_report":
                # Required params: output_path
                output_path = operation_params["output_path"]
                result = pipeline.generate_processing_report(output_path)
                
            else:
                raise ValueError(f"Unknown operation: {operation}")
            
            self.pipeline.value = pipeline
            self.result.value = result
            print(f"Pipeline operation '{operation}' completed successfully")
            
        except Exception as e:
            print(f"Error during pipeline operation '{operation}': {e}")
            raise
